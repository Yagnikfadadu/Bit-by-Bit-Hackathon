# Bit-by-Bit-Hackathon — Problem1
## CPA Attack for RSA (LTR: Square-then-Multiply)

**Short description**  
This repository implements a Correlation Power Analysis (CPA) attack against a Left-to-Right (MSB-first) RSA exponentiation (square-then-multiply). The leakage model is the Hamming weight of intermediate results. The attack recovers the secret exponent bit-by-bit by correlating hypothetical Hamming weights with measured power traces.

---

## Repository layout

- `main.py` — Trace acquisition script. Connects to the target, programs it, sends ciphertexts and captures power traces; produces `single_trace.csv`.
- `main_attack.py` — CPA attack implementation (preprocessing, hypothesis generation for LTR square-then-multiply, correlation, plotting, key recovery).
- `hw_test.py` — Verification script. Sends a candidate recovered key to the device and reads the returned plaintext to confirm recovery.
- `single_trace.csv` — CSV of captured traces (generated by `main.py`).
- `bit3.jpg`, `bit6.jpg`, `bit15.jpg` — Example per-bit CPA result images (optional).
- `report_with_known_bits.tex` (canvas: **Report With Known Bits**) — LaTeX report containing important code snippets and known-bits hints (already present in the canvas document).

---

## Quick requirements

- Python 3.8+
- `numpy`, `matplotlib`
- `scipy` *optional* (recommended for filtering / medfilt — code falls back if missing)
- For hardware capture (`main.py`) you need the corresponding capture library (e.g. ChipWhisperer) and the target firmware (e.g. `simpleserial_rsa-CW308_STM32F3.hex`).

Install core Python packages:
```bash
pip install numpy matplotlib scipy
# plus chipwhisperer or your capture library if required
````

---

## CSV format (`single_trace.csv`)

Each row represents one captured trace and follows:

```
<ciphertext_hex>, sample_0, sample_1, sample_2, ..., sample_{N-1}
```

* `ciphertext_hex` — ciphertext sent to the target (hex string, no `0x`).
* Remaining columns — floating-point trace samples (power/amplitude).
* `main.py` produces this format by default.

---

## How to use

### 1) Capture traces

Connect the capture device and target, ensure the correct firmware is loaded, then run:

```bash
python3 main.py
```

Configurable items inside `main.py`:

* `NUM_TRACES` — number of traces to capture
* `scope.adc.samples` — number of samples per trace (e.g. 800)
* Target/programmer parameters

**Tips**

* Increase `NUM_TRACES` when CPA decisions are noisy.
* Tighten trigger and capture windows on the oscilloscope around the exponentiation.

### 2) Run CPA attack (LTR)

Run:

```bash
python3 main_attack.py
```

If `main_attack.py` is a notebook, open it and execute cells. The attack pipeline:

1. Load `single_trace.csv`.
2. Baseline removal → optional bandpass filter (if `scipy` available).
3. Detect multiply spike window and align traces.
4. For each key bit (MSB → LSB) simulate two hypotheses (guess=0 / guess=1) using the LTR square-then-multiply model and Hamming-weight leakage model.
5. Compute Pearson correlation between each hypothesis and the trace window; choose the guess whose correlation trace has the larger absolute peak.
6. Plot per-bit correlation traces for visual inspection.

**Output**

* Recovered key (binary & decimal)
* Per-bit correlation peak values and plots

### 3) Verify with device

Edit or pass the recovered key to `hw_test.py` and run:

```bash
python3 hw_test.py
```

On success the device returns the plaintext (challenge expects `6267` on success).

---

## Known bits & attack hints (important)

Use these constraints to reduce search space and increase reliability:

* **Key length:** `d` is **15 bits** long.
* **Known bits:**

  * MSB = `1`
  * 4 LSBs = `0001`
* **Key pattern (known + unknown):**

  ```
  1 ? ? ? ? ? ? ? ? ? ? 0 0 0 1
  ```

  Only the 10 middle bits are unknown — fix MSB and LSBs in your hypothesis simulation to reduce ambiguity.

**Practical note:** In previous runs, the last recovered bit (one of the LSBs) did not match the expected value; likely causes are measurement noise or misalignment. Use the troubleshooting tips below.

---

## Troubleshooting & tips to improve success

**If a bit is wrong (often LSB):**

* Revisit alignment—tune `align_traces` parameters and `search_radius`.
* Increase `NUM_TRACES` to improve SNR.
* Inspect the mean trace: adjust `SPIKE_WIDTH` (narrow the window) or manually pick `start`/`end`.
* Enable better preprocessing: median baseline removal, or bandpass filter (requires `scipy`).

**SNR improvements**

* Collect more traces or average multiple captures per ciphertext.
* Tighten oscilloscope capture windows to reduce unrelated signal.
* Apply median filtering to suppress low-frequency drift.

**Decision robustness**

* Instead of a greedy per-bit choice, use beam search / top-k candidate tracking and verify candidates with `hw_test.py`.
* Check both correlation peak amplitude and peak index consistency across bits.

---

## Suggested immediate actions (when a bit mismatch occurs)

1. Recompute CPA with MSB and LSBs fixed in simulation (reduces hypothesis ambiguity).
2. Increase traces per bit or use ensemble averages per hypothesis to boost SNR.
3. If verification fails, run `hw_test.py` against the top-k candidate keys (sorted by CPA confidence) to find the correct key under noisy conditions.

---

## Example run (sample output)

Loaded 300 traces, each with 800 samples.
Preprocessed traces shape (after baseline & alignment): (300, 800)
Spike window used for CPA: samples 0..265

[ltr] Bit 1/15 -> chosen=1 (peak=0.313556)
...
[ltr] Bit 15/15 -> chosen=0 (peak=0.167512)

LTR cumulative peak sum: 3.082636, recovered key: 110011011110000 -> 26352

# Brute-force Verification (Problem1) — ChipWhisperer

This document contains a practical brute-force verification script for Problem1 (RSA CPA attack).  
It's intended as a *fallback* or final confirmation step: after using CPA to narrow down candidate keys, this script will try all remaining candidates and check the device's plaintext reply.

> **Why this is feasible here:** the secret exponent is 15 bits long and 10 bits are unknown. Brute-forcing \(2^{10} = 1024\) candidates is trivial for modern hardware.

---

## Prerequisites

- Python 3.8+
- `chipwhisperer` Python package (matching your capture setup)
- Target device and capture hardware connected
- Firmware used by the target (example in script): `simpleserial_rsa-CW308_STM32F3.hex`
- Adjust `scope.adc.samples` and other hardware settings if necessary

---

## Script (save as `bf_verify.py`)

```python
import chipwhisperer as cw
import time

# --- 1. CONNECT TO HARDWARE ---
try:
    scope = cw.scope()
    target = cw.target(scope)
    print("Hardware connected.")
except IOError as e:
    print(f"Could not connect to ChipWhisperer hardware: {e}")
    # Exit the script if hardware connection fails
    exit()

scope.default_setup()
time.sleep(1)  # Give the device a moment to settle

# --- 2. KEY PARAMETERS ---
# The key is 15 bits long.
# Known Bits: MSB is 1, LSBs are 0001.
# Key format: 1??????????0001
# We need to brute-force the 10 unknown bits.
KNOWN_MSB = 1 << 14  # The MSB is 1 at position 14
KNOWN_LSBS = 1  # The LSBs (0001) give a value of 1
NUM_UNKNOWN_BITS = 10
VERIFICATION_PLAINTEXT = 6267

# --- 3. PROGRAM THE TARGET ---
prog = cw.programmers.STM32FProgrammer
print("Programming target...")
cw.program_target(scope, prog, "simpleserial_rsa-CW308_STM32F3.hex")
print("Programming done.")

# --- 4. CONFIGURE CAPTURE SETTINGS ---
scope.clock.adc_src = "clkgen_x1"
scope.adc.samples = 5000  # You can adjust this value

# --- 5. BRUTE-FORCE LOOP ---
print(f"Starting brute-force of {2 ** NUM_UNKNOWN_BITS} possible keys...")
found_key = False
for i in range(2 ** NUM_UNKNOWN_BITS):
    # Construct the full 15-bit key using bitwise operations
    # The unknown bits (i) are shifted into position (4 through 13)
    candidate_key = KNOWN_MSB | (i << 4) | KNOWN_LSBS
    # Pack the key into 2 bytes for communication
    key_bytes = candidate_key.to_bytes(2, 'big')

    # --- 6. VERIFICATION LOGIC ---
    try:
        # Send the candidate key as a ciphertext to the target
        target.simpleserial_write('p', key_bytes)

        # Read the plaintext response from the target
        # The firmware will output a 2-byte plaintext
        resp = target.simpleserial_read('r', 2)

        # Convert the response bytes to an integer
        response_int = int.from_bytes(resp, 'big')

        print(f"Attempt {i + 1}/{2 ** NUM_UNKNOWN_BITS}: Testing key {candidate_key} -> Response: {response_int}")

        # Check if the response matches the expected plaintext
        if response_int == VERIFICATION_PLAINTEXT:
            print("\n==============================")
            print("SUCCESS! The private key is:")
            print(f"Decimal: {candidate_key}")
            print(f"Binary: {bin(candidate_key)}")
            print("==============================")
            found_key = True
            break  # Exit the loop once the key is found

    except Exception as e:
        print(f"Error during verification attempt for key {candidate_key}: {e}")
        # Continue to the next key if there's a communication error

if not found_key:
    print("\nBrute-force complete. The correct key was not found.")

# --- 7. CLEANUP ---
scope.dis()
target.dis()
print("Disconnected from hardware.")
````

---

## Usage

1. Save the script to `bf_verify.py` (or a name you prefer).
2. Make sure your ChipWhisperer hardware is connected and accessible on the host machine.
3. Ensure the correct firmware file path is set in the script (replace `"simpleserial_rsa-CW308_STM32F3.hex"` if needed).
4. Run:

   ```bash
   python3 bf_verify.py
   ```

The script will program the target, iterate over all 1024 candidate keys, send each candidate as a ciphertext (2 bytes), read the 2-byte plaintext reply, and compare it to the expected verification plaintext (default `6267`).

```
